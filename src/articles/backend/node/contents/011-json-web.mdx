---
title: "Stateless Token Based Authentication"
description: ""
published_date: ""
last_updated_date: ""
syllabus_code: "BAC003"
authors: "kelvinsekx"
---

After we've learned to store a user's password securely on signup, the next phase is to let authenticated user access resources peculiar to them. This is managed by assigning a session or token upon login.

## Login

After a user is signed up, it is best practice to re-verifying their credentials (username and password) called Login. This involves authenticating the user against their saved information, and upon successful verification authorizes them (give access) to their data and features.

On the code end, login retrieves the plain text password, hashes it and check the hashed value against the hash stored in the database. A token is issued if a match is found. This token is a secure, temporary and unique **string of data** issued by a server to a client after successfuly login. This saves users the stress of sending their password and username on every request to gated resources. The token is a prove of the client indentity and authorization.

Tokens are communicated in two broad ways: as Cookies or as Bearer tokens to be stored in the local storage.

If the client is a web app, using a Cookie is fine. But if it is intended for a mobile app, Bearer tokens are a better alternative because the mobile app don't handle Cookies as well as the web does.

## Authentication with Cookies

One of the ways to communicate tokens with clients is with Cookies.

Create a login path and a handler like below:

```bash
import crpto from 'crypto;'

...

app.post('/login', (req, res)=> {
    const credential = req.body;
    const user = DATABASE.find(c => c.username === credential.username);

    if(!user) return res.status(400).json({error: 'User don\'t exist'})
    res.status(200).json({message: 'User found'});
})
```

Then add some routes

```bash
...

app.get('/protected', authenticatedToken, (req, res)=>{
    res.status(200).json({message: 'welcome to your protected route'});
 })

app.get('/non-protected', (req, res)=>{
    res.status(200).json({message: 'welcome to an unprotected route'});
})

```

```bash
app.post('/login', (req, res)=> {
    const credential = req.body;
    const user = DATABASE.find(c => c.username === credential.username);

    if(!user) return res.status(400).json({error: 'User don\'t exist'})

    let hasMatch = false;
    const hashed = await hashFn(credential.password, user.salt)

    hasMatch = hashed === user.password;

    if(!hasMatch) return res.status(400).json({error: 'Username and password incorrect'})
    res.status(200).json({message: 'User found'});
})
```

Let's add sending a Cookie to our client

```bash
app.post('/login', (req, res)=> {
    const credential = req.body;
    const user = DATABASE.find(c => c.username === credential.username);

    if(!user) return res.status(400).json({error: 'User don\'t exist'})

    let hasMatch = false;
    const hashed = await hashFn(credential.password, user.salt)
    hasMatch = hashed === user.password;
    if(!hasMatch) return res.status(400).json({error: 'Username and password incorrect'})

    res.cookie('cookie-name', 'token', {
        httpOnly: true,
        secure: true,
        sameSite: true,
        maxAge: 1000 * 60 * 60
    })
    res.status(200).json({message: 'User found'});
})
```

<LongAside subject="Run in curl">
- Run the server, 
- signup with `curl -X POST localhost:3003/signup -H "Content-Type: application/json" -d '{"username": "janedoe", "password": "janedoesess"}'`
- login with `curl -v -X POST localhost:3003/login -H "Content-Type: application/json" -d '{"username": "janedoe", "password": "janedoesess"}'`

In the header output, you should see the **Set-Cookie** property with our cookie.

</LongAside>

After one hour, the browser will automatically delete the cookie. When the user makes another request, the cookie will no longer be present in the request headers.

If you have been following, you must have seen a looming problem: Our token isn't unique. Attackers could use the "token" string as cookie and have access to user's resources. To make our token unique, we would employ "JSON WEB TOKEN" package. This would help us create a simple unique key that we can easily unkey to get details about the user.

```bash
app.post('/login', async (req, res)=> {
  const credential = req.body;
  const user = DATABASE.find(c => c.username === credential.username);

  if(!user) return res.status(400).json({error: 'User don\'t exist'})

  let hasMatch = false;
  const hashed = await hashFn(credential.password, user.salt)

  hasMatch = hashed === user.password;

  if(!hasMatch) return res.status(400).json({error: 'Username and password incorrect'})

  delete credential.password;

  const token = jwt.sign(
    credential,
    `${process.env.MY_SECRET}`,
    {expiresIn: '1hr'}
  );

  res.cookie('cookie-name', token, {
      httpOnly: true,
      secure: true,
      sameSite: true,
      maxAge: 1000 * 60 * 60
  });

  return res.status(200).json({message: 'User found'});

})
```

## Authentication with Bearer Tokens

The JWT (JSON Web Token) are access tokens that can be used to make a secure API call when a client application needs to access a protected resources. We've discussed how to communicate Access tokens with Cookie and now we will discuss how to do it with Bearer toke.

Bearer tokens are Access tkens with Bearer prefix.

<Nudge text="Difference between Bearer token and Access token" />

```bash
app.post('/login', async (req, res)=> {
  const credential = req.body;
  const user = DATABASE.find(c => c.username === credential.username);

  if(!user) return res.status(400).json({error: 'User don\'t exist'})

  let hasMatch = false;
  const hashed = await hashFn(credential.password, user.salt)

  hasMatch = hashed === user.password;

  if(!hasMatch) return res.status(400).json({error: 'Username and password incorrect'})

  delete credential.password;

  const token = jwt.sign(
    credential,
    `${process.env.MY_SECRET}`,
    {expiresIn: '1hr'}
  );

  return res.status(200).json({
    message: 'User found',
    data: token
    });

})
```

The signed in user can take the token, prefix it with Bearer, `Bearer ${token}`, attack it to the HTTP header.

<LongAside subject="Run example in curl">
- sign up
- log in
- try access a protected route with `curl -v -X GET localhost:3003/protected -H "Authorization: Bearer JWT-TOKEN"`

You should be able to see the protected response.

</LongAside>

Now that we know how to log a user in, did you notice both the JWT and Cookie have expiry property ( called maxAge in Cookies). Given that any malicious user could have access to a bearer token, we tend to make the expiry property short unlike our previous example with an hour long expiration, authorization token are meant to be less than 30 mins.

This leads to our next question, what happens when the JWT or Cookie expires? The natural approach would be for the user to login again. This experience is not user friendly. In this next section, we would talk about popular approach to improve this user experience.

## What happens when Access token expires

To mitigate the user experience of having to log in again after an access token experience, several approaches can be employed, one of which is the use of Refresh Token.

A refresh token can be used to obtain a new access token without requiring the user to log in again. When the access token expires, the client can use the refresh token to request a new access token

```bash
function AuthenticateMiddleware(req, res, next) {

    let token = '';
    if(req.cookies['cookie-name']){
      token = req.cookies['cookie-name']
    }else if(req.headers.authorization){
      token = req.headers.authorization.split(' ')[1]
    }

  if(token){
    const user = jwt.verify(token, `${process.env.MY_SECRET}`, (err, user)=> {
      if(err){
        res.clearCookie('cookie-name')
        return res.status(403).json({error: 'token is invalid or expired'});
      }
    });
    req.user = user;
    next();
  } else{
    return res.status(401).json({error: 'no authorization found'})
  }
}
```

<Nudge text="ID Tokens vs Refresh Tokens vs Access Tokens" />

With the use of refresh token, comes another challenge. Given refresh tokens validity are longer, say days if an attacker have access to it, new access token can get generated just like if they had the access token instead. One way out of challenge is the use of **Refresh Token Rotation**. After the access token expires, we invalidate old refresh token wile issuing a new access token.
