---
title: "Webserver with Nest"
description: ""
published_date: "17/07/2025"
last_updated_date: "02/11/2025"
syllabus_code: "BAC001"
authors: "kelvinsekx"
---

Nest, also referred as Nest.js and NestJS, is an HTTP web meta-framework built on top of ExpressJS. The same way Express is built on top of Node. But unlike Express, Nest forces you to use some predefined architecture for your backend code.

In this lesson, I'll introduce you to Nest.js. We'll replicate [the application with Express from previous lesson ](/learn/backend/node/007-webservers-with-express). The same lesson combines as a prerequisite for this one.

## Your first Nest program

Follow these 2 simple steps:

1. Install nest CLI `$ npm install -g @nestjs/cli`.

   On successful installation run `$ nest -v` to show the current version. If you see a number, we can assume everything is fine and `nest` is available globally.

2. Create new application with `$ nest new project-name`.

   You'll be asked to choose a package manager. I use NPM, either Yarn or Pnpm is fine. Once the initialization is complete, you'll find instructions to start the application.

   The `nest new` command creates a functional application with a base structure on which you can extend your implementation on.

3. Go to your browser. Visit `localhost:3000` where you should see an "Hello World!" on screen.

<LongAside subject="If port 3000 is in use, customize to a different port number">
  On some rare cases, you may want to customize the default port for reasons
  like port:3000 been used by another program. Go to the `main.ts` file in the
  src directory. Change the port from 3000 to a preferred port of yours say
  8686.
</LongAside>

## Existing Structures in a Nest Application

**The basic structure in a Nest application are modules, controllers, and services**. In a large project you want to keep things simple and these structures have enough to server your needs. In case when you want to hack past the basics, their are existing structures provided by Nest. They are are application, class, configuration, decorator, filter, gateway, guard, interceptor, interface, middleware. module, pipe, provider, resolver, library, sub-app and resource.

Instead of writing these files/structures by hand all the time, we use the Nest's `generate` command.

#### Routing with `@controller()` decorator

Routes and request handling are solely handled in the controller layer in Nest. NestJS routes request to the request handler function that must be defined in a class marked as a controller.

**To mark a class as a controller**, the `@controller()` decorator must be applied to a defined class, and this class must be exported to be accessible for registration in the Nest module. Lets take the "app.controller.ts" file in the src folder of your new "project-name" app.

Remove the getHello method so that it looks exactly like the code below

```bash
// src/app.controller.ts
import { Controller } from '@nestjs/common';

@Controller() // controller applied to a defined class AppController
export class AppController {

}
```

The `@controller()` decorator takes an optional path prefix. This establishes a **base path** for all routes defined within that controller. If a controller takes a prefix of _'/api'_ `@controller('/api')`, it would prepend its **handler routes** with the _'/api'_ so that route handler defined with '/users' would be addressable as _'/api/users'_.

### Route handlers with HTTP verb decorators

The HTTP verb (or HTTP method) decorators are primarily used for two things:

1. to define the HTTP method, and
2. to define a route path by extending its base controller route.

To create a route handler, combine the HTTP verb decorators with a method in a controller class. Nest has a number of them like `@Get()`, `@Post()`, `@Put()`, `@Delete()`, `@Patch()`, `@Options()`, and `@Head()`, that can be used with an HTTP method to create handler routes.

```bash
import { Controller, Get } from '@nestjs/common';

@Controller()
export class AppController {
   @Get() // defines a handler routes
   findAll(): string{
      return 'this action returns all items'
   }
}
```

To send an HTTP response, simple return a value from the route handler method applied. Nest will auto serialize these values into a valid JSON and wrap it in a response body.

```bash
   @Get()
   findAll(){
      // return 'this returns all items'
      // return ['biscuit', 'milk']
      /* return {
      *     items: ['biscuit', 'milk']
      *  }
      */
   }
```

<LongAside subject="Express option for sending responses">
  An alternate approach to generating responses in Nest.js is to use Express
  response object directly. Nest.js would inject a response object into a
  handler method using the @Res() decorator.

```bash
import { Controller, Get, Res } from '@nestjs/common';
import { Response } from 'express'

@Controller()
export class AppController {
   @Get() // defines a route handler
   findAll(@Res() res: Response){
      return res.status(200).json(['kelvin', 'Adeyanju'])
   }
}
```

</LongAside>

<AsideNote>
  Instead of writing controllers by hand, Nest.js devs rely on a familiar
  wand, nest/cli, to create these things. Use `$ nest
  generate controller <name>` to create a controller boilerplate.

| File                    | Use                                       |
| ----------------------- | ----------------------------------------- |
| note.controller.ts      | A controller with a single route          |
| note.controller.spec.ts | Unit tests for the accompanied controller |

</AsideNote>

## Route parameters and request body

The controller base route and http decorator routes combines to form the URL path. This path sometime takes a route parameter. All the route parameters in a path can then be accessed with the `@Param()` decorator function applied to a variable.

In the example below, `@Param('item')` decorator is applied to the `item` variable: `@Param('item') item`. We added some typescript to type the item as a string with `{item: string}` so we now have `@Param('item') item: {item: string}`.

```bash
import { Controller, Get } from '@nestjs/common';
import { Response } from 'express'

@Controller()
export class AppController {
   @Get(":item") // defines a route handler
   findItem(@Param('item') item: { item: string }){
      return ['biscuit', item]
   }
}
```

You can send a Post request and have access to the request.body using the `@Body()` decorator.

```bash

   private items = ['biscuit', 'milk'];

   @Get() // defines a route handler
   findAll(){
      return this.items
   }

   @Get(":item") // defines a route handler
   findItem(@Param('item') item: { item: string }){
      return this.items.filter(n => n == item)
   }

   @Post()
   addNewItem(@Body() body: { item: string }){
      this.items.push(item)
      return this.items
   }

```

## Separate business logic in services

To promote separation of concerns, we ensure the controller does one thing and does it well: match HTTP requests with handlers. From our previous examples, we situated the logic in the controller. Let's change this so that the handler function simple points to a service function.

Request -> Controller -> Service

**To mark a class as a service**, the `@Injectable()` decorator must be applied to a defined class, and this class must be exported to be accessible in Nest module to be register as a **provider**.

<AsideNote>
  In Nest.js, the terms "provider" and "service" are often used interchangeably
  but they refer to sightly different concepts. For example the AppService is
  registered in the Nest module as a provider and not a service. By using the
  term "service", we're emphasizing the role of the class in providing a
  specific functionalitiy or service to the application rather than just its
  technical implementation as a provider.
  <LongAside subject="Provider">
    A provider is a class that is registered in the Nest.js dependency injection
    container and can be injected into other components.
  </LongAside>
  <br />
  <LongAside subject="Service">
    A service is a specific type of provider that encapsulates business logic
    that is used by controllers. Services are providers but not all providers
    are services. Providers can be Services, Repositories, Factories, Guards,
    Interceptors
  </LongAside>
</AsideNote>

Take the "app.service.ts" file in the src folder of your new "project-name" app. Remove the getHello method so that it looks exactly like the code below:

```bash
// A valid controller
import { Injectable } from '@nestjs/common';

@Injectable() // controller applied to a defined class AppController
export class AppService {

}
```

<LongAside subject="What is happening in console output">
  In the console output... If the application is extended, this is the place to
  start troubleshooting your application.
</LongAside>

## Conclusion

You've reached the end of the first phase, a fit many struggle to beat. Don't stop now.

## References

### Footnotes

1. [NestJS installation](https://docs.nestjs.com/#installation) _Pasted on Sun, Nov 02, 2025._
