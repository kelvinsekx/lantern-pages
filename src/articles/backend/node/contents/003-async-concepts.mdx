---
title: "Node Async and Event Loop"
description: "A thorough lesson on the intricacies of node's async and event loop"
published_date: "09/07/2025"
last_updated_date: "09/07/2025"
syllabus_code: "BAC001"
authors: "kelvinsekx"
---

Node and the entire JavaScript ecosystem is built on async and the event loop fundamentals. The mastery of these topics can be liberating, but they can also feel more like abstractions especially if you are new to programming.

## What's Async

When we say an operation or task runs async in Node, we mean they run **asynchronously**. This kind of tasks usually take more time to complete ( i.e long running operations).
Async is both a concept and keyword in Node ( and JavaScript). We will discuss its pov as a keyword later in this lesson.

Node associates **async** operations ( or tasks) with **events**. Whenever they are triggered, they are run independently from other non-async operations. And when they are done, it cedes control back to the main event loop to handle ( instead of blocking this loop).

Thanks to async, tasks are not forced to wait after another. If a task takes more time (i.e async), it should be moved to a separate lane while the rest of program goes on un-interrupted.

Examples of async tasks ( or operations) are writing/reading a file, network fetches.

<LongAside subject="Explanation with some layman examples">
  For example, **the process of sewing by one person synchronously**. As a taylor, you can not stich a cloth until they are cut in pieces patterns. After cutting, you would have to weave (depending on the material) before sewing and so on. In a nutshell, you can not go on with another process until the first is done.

But let's use another example with **a Baker who bakes asynchromously**. They start by spreading cream while the machine is mixing the cake. If it is done to taste, you can leave what you are doing to go back to the mixed cake.

These scenarios represent Async and Sync concepts well. Async guarantees your node program can keep running while another piece of the program is doing something else that usually takes time or slow. These kind of operations are taken off the execution flow.

</LongAside>

Async events are handled by handlers. These handlers can be expressed in 3 broad patterns: **Callbacks**, **Promises** (and Async/Await) and **Listeners**.

## Callbacks

Before JavaScript empowered us with an intuitive way of handling async tasks, Node gave us Callbacks. Callbacks are functions that are called after an async task is done.

Imagine giving an instruction that if the bake is done smoothing, a sound should peep.

```bash
cake("be mixing", (err, done){
    if(!err){
        done(peep)
    }
})
```

Another example would be reading from the drive or filesystem. Until recently with faster computers, it takes a substantial time to read from drives. You don't want to delay your entire program waiting for a feedback from your drive.

**Synchronously reading a file**

```bash
import {readFileSync} from "fs";

let fileName
console.log("Hello")
// prints "Hello" -> GoToNextLine

fileName = readFileSync('file.txt')
// takes 10 secs -> call done() -> GoToNextLine

console.log(fileName)
// prints "FileName.txt" -> ends
```

<AsideNote note="Callback style">
I make these mistakes myself so I think it is
important to put a little more attention here.

When writing a callback function for an async operation in node, it is important to keep these two vital points in mind:

1.  Node's callback style is referred to as "error-first callback style". Callbacks must always **have an error as its first argument**.
2.  Callback functions would usually be the last argument for an async function. See the example below.

</AsideNote>

**Asynchronously reading a file**

```bash
import { readFile } from "fs";

let fileName
console.log("Hello")
// prints "Hello" -> GoToNextLine

readFile('file', (err, done)=> {})
// leaves execution flow -> GoToNextLine immediately -> takes 10 secs in background -> call done() if successful (i.e no error)

console.log(fileName)
// prints undefined -> ends
```

<LongAside subject={'A little beyond: Async in series and parallel'}>

Although most of our examples while doing asyn operations would be with a sigle identity, in rare cases, often than not, you would have to make async operations for multiple things at a time. For example an array of items.

An example where this shine is trying to read all the files in a directory. You can either do these async operations in series or parallel. Let's make an example of reading a folder and list the length of the files in the directory/folder.

We might be tempted to do this.

```bash
fs.readdir('foldername', (err, files){
    if(err) throw new Error(err)
    files.forEach((f)=> {
        fs.readFile(f, (err, result){
            if(err){
                throw new Error(err)
            }
            console.log(result.length)
        })
    })
})
```

The problem with our former example is that the length of files would not come in the order of the files in our directory.

To solve this, we can make the operations in series. One after another, and what else algorithm shines here if not recursion. See example below:

```bash
import fs from "fs";
import path from "path";

fs.readdir("ddd", (err, files)=>{
  if(err) throw new Error(err);

  function readFiles(i){
    if(i >=files.length) return; // exit
    fs.readFile(path.join("ddd", files[i]), (err, content)=> {
        if(err) throw new Error(err);
        console.log(content.toString())
        readFiles(i+1)
    })
 }

 readFiles(0)

})
```

There are a number of ways to solve this aside doing the operations one step at a time. The problem with this approach of mine is that the async operations are not made at parallel. Instead they are made one after the other which can be slow too except in cases like we do where the files in dir aren't much.

```bash
import fs from "fs";
import path from "path";

fs.readdir("ddd", (err, files)=>{
  if(err) throw new Error(err);
  const results = [];
  let isRemaining = files.length;

  files.forEach((file, index)=> {
    --isRemaining
    fs.readFile(path.join("ddd",file), (err, readContent)=>{
      if(err) throw new Error(err);
      results[index] = readContent;

      if(!isRemaining) console.log(results.toString());
    })
  })
})
```

This way all the files are called in parallel and their results saved based off their indexes so that we can access them orderly.

</LongAside>

**Callbacks are great but they have their limitations** like the pyramid of doom ( also known as Callback Hell). In addition, Callback handlers weren't symbolic to async operations <RefN>2</RefN>. In fact, it can be confusing sometimes because non-blocking functions use them too. They can also have major concerns with coupling.

The community brought about **Promises** that can help handle these limitations better. Let's talk about it next.

## Promises

Instead of passing callback functions as argument to an async ops to handle the error and success in same place, a Promise is an object that allows us to handle (or better still watch for) success or error and separately chain multiple async calls to handle these events (instead of nesting with callbacks).

Let's promisify our previous callback code. Promisifying is the transformation of callback based methods to promise.

```bash
import { readFile } from 'fs';

let filename;

function promisify(fn){
  return function(file, cb = ()=>{}){
   return new Promise((resolve, reject)=>{
      fn(file, (err, data)=> {
        if(err) reject(err);
        else resolve(data)
      })
    })
  }
}

const promisifiedReadFile = promisify(readFile);
promisifiedReadFile('note.txt')
  .then(data => console.log(data.toString()))
  .catch(e => console.log(e))
```

The promisify function we used in the code above is in fact available for us as node util.

```bash
import { readFile } from 'node:fs';
import { promisify } from 'node:util';

let filename;

const promisifiedReadFile = promisify(readFile);
promisifiedReadFile('note.txt')
  .then(data => console.log(data.toString()))
  .catch(e => console.log(e))
```

### The Async keyword

Chaining promise handlers can be simpllified even more to feel like a sync ops. There is the Async/Await keywords, they do these things:

1. improve readability of async codes.
2. simplifies variable scopes around async codes.
3. improve error handling.

```bash
import { readFile } from 'node:fs';
import { promisify } from 'node:util';

let filename;

const promisifiedReadFile = promisify(readFile);

try {
  const data = await promisifiedReadFile('note.txt');
  console.log(data.toString());
}catch(err){
  console.log(err)
}
```

<LongAside subject="The Event Loop">

When dealing with async operations, it can sometimes be important to understand how multiple asyc operations and their handlers are managed or in what order they get back to the main thread. To answer these questions, we need to understand **The call stack**, **event queues** and the **the event loop**.

</LongAside>

## Listeners and Event Emitters

Another handler method that takes the game to a different elvel is the use of Event Listeners created with Emitter object.

An Emitter object has two main features:

1. Emitting named events
2. Registering ( and unregistering) listener functions.

To create an event emitter object, we can instantiate from the EventEmitter class or any class that extends it.

```bash
import fs from 'node:fs';
import {EventEmitter} from 'node:events'

class ReaderEmitter extends EventEmitter {
  readFile(file){
    fs.readFile(file, (err, data)=> {
      if(err){
        this.emit('error', err);
        return
      }
      this.emit('data', data.toString());
    })
  }
}

const reader = new ReaderEmitter();

reader.on('data', data => { console.log(data) });
reader.on('error', err=> { throw new Error(err) });

reader.readFile('note.txt')
```

## Questions to research on

- How exactly does an handler function get executed in the main thread after its async operation is done outside the main event loop?
- If JS runs on a single thread, what thread does an async operation run on?
- When a function is called/completed, it reference gets popped out of the call stack. How does JavaScript knows if an async task is completed? What is used to identify its reference?

## References

### Footnotes

1. [Definition for Promises](https://martinfowler.com/bliki/JavascriptPromise.html) _Pasted on Tue, Jul 29, 2025._
2. [A stackoverflow thread where devs are confused with the role of callback in sync ops](https://stackoverflow.com/questions/37473227/why-not-just-call-a-function-from-another-function-instead-of-using-a-callback) _Pasted on Sat, Aug 02, 2025._
3. [Why Promises over Callbacks](https://www.blinkingcaret.com/2014/07/14/promises-vs-callbacks/) _Pasted on Tue, Jul 29, 2025._
4. [Pyramid of doom and troubles with additional indentation](<https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)>) _Pasted on Tue, Jul 29, 2025._
